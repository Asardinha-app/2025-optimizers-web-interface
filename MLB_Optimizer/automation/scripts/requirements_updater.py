#!/usr/bin/env python3
"""
Requirements Updater for MLB Optimizer
Automatically keeps requirements.txt current with latest library versions.
"""

import subprocess
import sys
import json
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('automation/logs/requirements_updater.log'),
        logging.StreamHandler()
    ]
)

class RequirementsUpdater:
    """Automatically keeps requirements.txt current with latest library versions."""
    
    def __init__(self):
        self.optimizer_dir = Path(__file__).parent.parent.parent
        self.automation_dir = self.optimizer_dir / "automation"
        self.requirements_file = self.optimizer_dir / "requirements.txt"
        self.requirements_backup = self.automation_dir / "backups" / "requirements_backup.txt"
        
        # Core libraries that must be kept current
        self.core_libraries = {
            'numpy': '1.20.0',
            'pandas': '1.3.0', 
            'ortools': '9.0.0',
            'scipy': '1.7.0'
        }
        
        # Optional libraries that enhance functionality
        self.optional_libraries = {
            'requests': '2.25.0',
            'packaging': '20.0.0'
        }
    
    def get_current_requirements(self) -> Dict[str, str]:
        """Get current requirements from requirements.txt."""
        requirements = {}
        
        if self.requirements_file.exists():
            try:
                with open(self.requirements_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            if '==' in line:
                                package, version = line.split('==', 1)
                                requirements[package.lower()] = version
                            elif '>=' in line:
                                package, version = line.split('>=', 1)
                                requirements[package.lower()] = f">={version}"
                            else:
                                package = line
                                requirements[package.lower()] = "latest"
            except Exception as e:
                logging.error(f"Error reading requirements.txt: {e}")
        
        return requirements
    
    def get_latest_versions(self) -> Dict[str, str]:
        """Get latest versions of all libraries from PyPI."""
        latest_versions = {}
        
        all_libraries = {**self.core_libraries, **self.optional_libraries}
        
        for lib_name in all_libraries.keys():
            try:
                import requests
                response = requests.get(f"https://pypi.org/pypi/{lib_name}/json", timeout=10)
                if response.status_code == 200:
                    latest_version = response.json()['info']['version']
                    latest_versions[lib_name] = latest_version
                else:
                    logging.warning(f"Could not get latest version for {lib_name}")
                    latest_versions[lib_name] = "unknown"
            except Exception as e:
                logging.warning(f"Error getting latest version for {lib_name}: {e}")
                latest_versions[lib_name] = "unknown"
        
        return latest_versions
    
    def backup_current_requirements(self) -> bool:
        """Create a backup of current requirements."""
        try:
            if self.requirements_file.exists():
                self.requirements_backup.parent.mkdir(exist_ok=True)
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_file = self.requirements_backup.parent / f"requirements_{timestamp}.txt"
                
                with open(self.requirements_file, 'r') as src, open(backup_file, 'w') as dst:
                    dst.write(src.read())
                
                logging.info(f"âœ… Requirements backed up to: {backup_file}")
                return True
            else:
                logging.info("â„¹ï¸  No requirements.txt to backup")
                return True
        except Exception as e:
            logging.error(f"âŒ Failed to backup requirements: {e}")
            return False
    
    def update_requirements_file(self, latest_versions: Dict[str, str]) -> bool:
        """Update requirements.txt with latest versions."""
        try:
            # Create new requirements content
            requirements_content = """# MLB_Optimizer Requirements
# Auto-generated by requirements_updater.py
# Last updated: {timestamp}

# Core Libraries (Required)
""".format(timestamp=datetime.now().isoformat())
            
            # Add core libraries
            for lib_name in self.core_libraries.keys():
                if lib_name in latest_versions and latest_versions[lib_name] != "unknown":
                    requirements_content += f"{lib_name}=={latest_versions[lib_name]}\n"
                else:
                    # Fallback to minimum version
                    requirements_content += f"{lib_name}>={self.core_libraries[lib_name]}\n"
            
            requirements_content += "\n# Optional Libraries (Enhanced Functionality)\n"
            
            # Add optional libraries
            for lib_name in self.optional_libraries.keys():
                if lib_name in latest_versions and latest_versions[lib_name] != "unknown":
                    requirements_content += f"{lib_name}=={latest_versions[lib_name]}\n"
                else:
                    # Fallback to minimum version
                    requirements_content += f"{lib_name}>={self.optional_libraries[lib_name]}\n"
            
            # Write new requirements file
            with open(self.requirements_file, 'w') as f:
                f.write(requirements_content)
            
            logging.info(f"âœ… Requirements updated: {self.requirements_file}")
            return True
            
        except Exception as e:
            logging.error(f"âŒ Failed to update requirements: {e}")
            return False
    
    def install_updated_requirements(self) -> bool:
        """Install updated requirements."""
        try:
            logging.info("ğŸ”„ Installing updated requirements...")
            
            result = subprocess.run([
                sys.executable, '-m', 'pip', 'install', '-r', str(self.requirements_file)
            ], capture_output=True, text=True, check=True)
            
            logging.info("âœ… Requirements installed successfully")
            return True
            
        except subprocess.CalledProcessError as e:
            logging.error(f"âŒ Failed to install requirements: {e}")
            logging.error(f"Error output: {e.stderr}")
            return False
        except Exception as e:
            logging.error(f"âŒ Error installing requirements: {e}")
            return False
    
    def check_requirements_compliance(self) -> Dict:
        """Check if current installation matches requirements."""
        compliance_report = {
            'installed': {},
            'missing': [],
            'outdated': [],
            'compliant': True
        }
        
        try:
            # Get current requirements
            current_requirements = self.get_current_requirements()
            
            for package, required_version in current_requirements.items():
                try:
                    # Check if package is installed
                    result = subprocess.run([
                        sys.executable, '-c', f'import {package}; print({package}.__version__)'
                    ], capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        installed_version = result.stdout.strip()
                        compliance_report['installed'][package] = installed_version
                        
                        # Check if version matches requirements
                        if required_version.startswith('>='):
                            min_version = required_version[3:]
                            if self._version_compare(installed_version, min_version) < 0:
                                compliance_report['outdated'].append(package)
                                compliance_report['compliant'] = False
                        elif required_version != "latest" and installed_version != required_version:
                            compliance_report['outdated'].append(package)
                            compliance_report['compliant'] = False
                    else:
                        compliance_report['missing'].append(package)
                        compliance_report['compliant'] = False
                        
                except Exception as e:
                    logging.warning(f"Could not check {package}: {e}")
                    compliance_report['missing'].append(package)
                    compliance_report['compliant'] = False
            
            return compliance_report
            
        except Exception as e:
            logging.error(f"Error checking compliance: {e}")
            return compliance_report
    
    def _version_compare(self, version1: str, version2: str) -> int:
        """Compare version strings."""
        try:
            from packaging import version
            return version.parse(version1).__cmp__(version.parse(version2))
        except ImportError:
            # Fallback version comparison
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            
            for i in range(max(len(v1_parts), len(v2_parts))):
                v1_part = v1_parts[i] if i < len(v1_parts) else 0
                v2_part = v2_parts[i] if i < len(v2_parts) else 0
                
                if v1_part < v2_part:
                    return -1
                elif v1_part > v2_part:
                    return 1
            
            return 0
    
    def run_full_update(self, force: bool = False) -> bool:
        """Run full requirements update process."""
        try:
            logging.info("ğŸš€ Starting requirements update process...")
            
            # Backup current requirements
            if not self.backup_current_requirements():
                logging.error("âŒ Failed to backup requirements")
                return False
            
            # Get latest versions
            latest_versions = self.get_latest_versions()
            
            # Update requirements file
            if not self.update_requirements_file(latest_versions):
                logging.error("âŒ Failed to update requirements file")
                return False
            
            # Install updated requirements
            if not self.install_updated_requirements():
                logging.error("âŒ Failed to install updated requirements")
                return False
            
            # Check compliance
            compliance = self.check_requirements_compliance()
            
            if compliance['compliant']:
                logging.info("âœ… Requirements are now up-to-date and compliant")
            else:
                logging.warning("âš ï¸  Requirements updated but some issues remain:")
                if compliance['missing']:
                    logging.warning(f"  Missing packages: {compliance['missing']}")
                if compliance['outdated']:
                    logging.warning(f"  Outdated packages: {compliance['outdated']}")
            
            return True
            
        except Exception as e:
            logging.error(f"âŒ Requirements update failed: {e}")
            return False
    
    def check_only(self) -> Dict:
        """Check requirements without updating."""
        try:
            logging.info("ğŸ” Checking requirements status...")
            
            current_requirements = self.get_current_requirements()
            latest_versions = self.get_latest_versions()
            compliance = self.check_requirements_compliance()
            
            print("\nğŸ“Š Requirements Status:")
            print("=" * 40)
            
            for lib_name in self.core_libraries.keys():
                current = current_requirements.get(lib_name, "Not specified")
                latest = latest_versions.get(lib_name, "Unknown")
                installed = compliance['installed'].get(lib_name, "Not installed")
                
                if lib_name in compliance['missing']:
                    status = "âŒ Missing"
                elif lib_name in compliance['outdated']:
                    status = "ğŸ”„ Outdated"
                else:
                    status = "âœ… Current"
                
                print(f"{lib_name}: {installed} (Required: {current}, Latest: {latest}) {status}")
            
            print(f"\nCompliance: {'âœ… Compliant' if compliance['compliant'] else 'âŒ Issues Found'}")
            
            return {
                'current_requirements': current_requirements,
                'latest_versions': latest_versions,
                'compliance': compliance
            }
            
        except Exception as e:
            logging.error(f"Error checking requirements: {e}")
            return {}

def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(description='MLB_Optimizer Requirements Updater')
    parser.add_argument('--check-only', action='store_true',
                       help='Only check requirements without updating')
    parser.add_argument('--force', action='store_true',
                       help='Force update even if recent update exists')
    parser.add_argument('--silent', action='store_true',
                       help='Run silently in background mode')
    
    args = parser.parse_args()
    
    # Configure logging for silent mode
    if args.silent:
        # Remove console handler for silent operation
        for handler in logging.root.handlers[:]:
            if isinstance(handler, logging.StreamHandler) and not isinstance(handler, logging.FileHandler):
                logging.root.removeHandler(handler)
        # Set logging to file only
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('automation/logs/requirements_updater.log')
            ]
        )
    
    updater = RequirementsUpdater()
    
    if args.check_only:
        logging.info("ğŸ” Checking requirements status...")
        
        current_requirements = updater.get_current_requirements()
        latest_versions = updater.get_latest_versions()
        compliance = updater.check_requirements_compliance()
        
        if not args.silent:
            print("\nğŸ“Š Requirements Status:")
            print("=" * 40)
            
            for lib_name in updater.core_libraries.keys():
                current = current_requirements.get(lib_name, "Not specified")
                latest = latest_versions.get(lib_name, "Unknown")
                installed = compliance['installed'].get(lib_name, "Not installed")
                
                if lib_name in compliance['missing']:
                    status = "âŒ Missing"
                elif lib_name in compliance['outdated']:
                    status = "ğŸ”„ Outdated"
                else:
                    status = "âœ… Current"
                
                print(f"{lib_name}: {installed} (Required: {current}, Latest: {latest}) {status}")
            
            print(f"\nCompliance: {'âœ… Compliant' if compliance['compliant'] else 'âŒ Issues Found'}")
        
        return {
            'current_requirements': current_requirements,
            'latest_versions': latest_versions,
            'compliance': compliance
        }
    
    # Run full update
    success = updater.run_full_update(force=args.force)
    
    if success:
        if not args.silent:
            print("âœ… Requirements update completed successfully!")
        logging.info("âœ… Requirements update completed successfully!")
        sys.exit(0)
    else:
        if not args.silent:
            print("âŒ Requirements update failed!")
        logging.error("âŒ Requirements update failed!")
        sys.exit(1)

if __name__ == "__main__":
    main() 